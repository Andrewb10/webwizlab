<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ballpit Background</title>
    
    <!-- Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body, html {
            height: 100%;
            overflow: hidden;
            background: #000;
        }
        
        #ballpit-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="ballpit-container">
        <canvas id="ballpit-canvas"></canvas>
    </div>
    
    <script>
        // Convert Three.js imports to work with CDN
        const {
            Clock,
            PerspectiveCamera,
            Scene,
            WebGLRenderer,
            SRGBColorSpace,
            MathUtils,
            Vector2,
            Vector3,
            MeshPhysicalMaterial,
            ShaderChunk,
            Color,
            Object3D,
            InstancedMesh,
            PMREMGenerator,
            SphereGeometry,
            AmbientLight,
            PointLight,
            ACESFilmicToneMapping,
            Raycaster,
            Plane
        } = THREE;

        // Import RoomEnvironment (we'll create a simple alternative)
        class RoomEnvironment extends Scene {
            constructor() {
                super();
                // Simple room environment setup
                const geometry = new THREE.BoxGeometry(10, 10, 10);
                const material = new THREE.MeshBasicMaterial({ color: 0x404040, side: THREE.BackSide });
                const room = new THREE.Mesh(geometry, material);
                this.add(room);
            }
        }

        // Core Three.js setup class
        class ThreeCore {
            constructor(config) {
                this.config = { ...config };
                this.size = { width: 0, height: 0, wWidth: 0, wHeight: 0, ratio: 0, pixelRatio: 0 };
                this.render = this.defaultRender.bind(this);
                this.onBeforeRender = () => {};
                this.onAfterRender = () => {};
                this.onAfterResize = () => {};
                this.isVisible = false;
                this.isAnimating = false;
                this.isDisposed = false;
                this.clock = new Clock();
                this.time = { elapsed: 0, delta: 0 };
                
                this.initCamera();
                this.initScene();
                this.initRenderer();
                this.resize();
                this.setupEventListeners();
            }
            
            initCamera() {
                this.camera = new PerspectiveCamera();
                this.cameraFov = this.camera.fov;
            }
            
            initScene() {
                this.scene = new Scene();
            }
            
            initRenderer() {
                if (this.config.canvas) {
                    this.canvas = this.config.canvas;
                } else if (this.config.id) {
                    this.canvas = document.getElementById(this.config.id);
                } else {
                    console.error('Three: Missing canvas or id parameter');
                }
                this.canvas.style.display = 'block';
                
                const options = {
                    canvas: this.canvas,
                    powerPreference: 'high-performance',
                    ...(this.config.rendererOptions ?? {})
                };
                this.renderer = new WebGLRenderer(options);
                this.renderer.outputColorSpace = SRGBColorSpace;
            }
            
            setupEventListeners() {
                if (!(this.config.size instanceof Object)) {
                    window.addEventListener('resize', this.handleResize.bind(this));
                }
                
                this.intersectionObserver = new IntersectionObserver(this.handleVisibility.bind(this), {
                    root: null,
                    rootMargin: '0px',
                    threshold: 0
            </script>
</body>
</html>
                this.intersectionObserver.observe(this.canvas);
                document.addEventListener('visibilitychange', this.handleVisibilityChange.bind(this));
            }
            
            handleVisibility(entries) {
                this.isVisible = entries[0].isIntersecting;
                this.isVisible ? this.startAnimation() : this.stopAnimation();
            }
            
            handleVisibilityChange() {
                if (this.isVisible) {
                    document.hidden ? this.stopAnimation() : this.startAnimation();
                }
            }
            
            handleResize() {
                if (this.resizeTimeout) clearTimeout(this.resizeTimeout);
                this.resizeTimeout = setTimeout(this.resize.bind(this), 100);
            }
            
            resize() {
                let width, height;
                if (this.config.size instanceof Object) {
                    width = this.config.size.width;
                    height = this.config.size.height;
                } else if (this.config.size === 'parent' && this.canvas.parentNode) {
                    width = this.canvas.parentNode.offsetWidth;
                    height = this.canvas.parentNode.offsetHeight;
                } else {
                    width = window.innerWidth;
                    height = window.innerHeight;
                }
                
                this.size.width = width;
                this.size.height = height;
                this.size.ratio = width / height;
                
                this.updateCamera();
                this.updateRenderer();
                this.onAfterResize(this.size);
            }
            
            updateCamera() {
                this.camera.aspect = this.size.width / this.size.height;
                if (this.camera.isPerspectiveCamera && this.cameraFov) {
                    if (this.cameraMinAspect && this.camera.aspect < this.cameraMinAspect) {
                        this.adjustFOV(this.cameraMinAspect);
                    } else if (this.cameraMaxAspect && this.camera.aspect > this.cameraMaxAspect) {
                        this.adjustFOV(this.cameraMaxAspect);
                    } else {
                        this.camera.fov = this.cameraFov;
                    }
                }
                this.camera.updateProjectionMatrix();
                this.updateWorldSize();
            }
            
            adjustFOV(targetAspect) {
                const tan = Math.tan(MathUtils.degToRad(this.cameraFov / 2)) / (this.camera.aspect / targetAspect);
                this.camera.fov = 2 * MathUtils.radToDeg(Math.atan(tan));
            }
            
            updateWorldSize() {
                if (this.camera.isPerspectiveCamera) {
                    const fov = (this.camera.fov * Math.PI) / 180;
                    this.size.wHeight = 2 * Math.tan(fov / 2) * this.camera.position.length();
                    this.size.wWidth = this.size.wHeight * this.camera.aspect;
                }
            }
            
            updateRenderer() {
                this.renderer.setSize(this.size.width, this.size.height);
                
                let pixelRatio = window.devicePixelRatio;
                if (this.maxPixelRatio && pixelRatio > this.maxPixelRatio) {
                    pixelRatio = this.maxPixelRatio;
                } else if (this.minPixelRatio && pixelRatio < this.minPixelRatio) {
                    pixelRatio = this.minPixelRatio;
                }
                this.renderer.setPixelRatio(pixelRatio);
                this.size.pixelRatio = pixelRatio;
            }
            
            startAnimation() {
                if (this.isAnimating) return;
                
                const animate = () => {
                    this.animationId = requestAnimationFrame(animate);
                    this.time.delta = this.clock.getDelta();
                    this.time.elapsed += this.time.delta;
                    this.onBeforeRender(this.time);
                    this.render();
                    this.onAfterRender(this.time);
                };
                
                this.isAnimating = true;
                this.clock.start();
                animate();
            }
            
            stopAnimation() {
                if (this.isAnimating) {
                    cancelAnimationFrame(this.animationId);
                    this.isAnimating = false;
                    this.clock.stop();
                }
            }
            
            defaultRender() {
                this.renderer.render(this.scene, this.camera);
            }
            
            dispose() {
                this.stopAnimation();
                this.intersectionObserver?.disconnect();
                window.removeEventListener('resize', this.handleResize.bind(this));
                document.removeEventListener('visibilitychange', this.handleVisibilityChange.bind(this));
                this.renderer.dispose();
                this.isDisposed = true;
            }
        }

        // Mouse/Touch interaction system
        const pointerMap = new Map();
        const currentPointer = new Vector2();
        let listenersActive = false;

        function createPointerInteraction(config) {
            const interaction = {
                position: new Vector2(),
                nPosition: new Vector2(),
                hover: false,
                touching: false,
                onEnter() {},
                onMove() {},
                onClick() {},
                onLeave() {},
                ...config
            };

            if (!pointerMap.has(config.domElement)) {
                pointerMap.set(config.domElement, interaction);
                if (!listenersActive) {
                    setupPointerListeners();
                    listenersActive = true;
                }
            }

            interaction.dispose = () => {
                pointerMap.delete(config.domElement);
                if (pointerMap.size === 0) {
                    removePointerListeners();
                    listenersActive = false;
                }
            };

            return interaction;
        }

        function setupPointerListeners() {
            document.body.addEventListener('pointermove', handlePointerMove);
            document.body.addEventListener('pointerleave', handlePointerLeave);
            document.body.addEventListener('click', handleClick);
            document.body.addEventListener('touchstart', handleTouchStart, { passive: false });
            document.body.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.body.addEventListener('touchend', handleTouchEnd, { passive: false });
        }

        function removePointerListeners() {
            document.body.removeEventListener('pointermove', handlePointerMove);
            document.body.removeEventListener('pointerleave', handlePointerLeave);
            document.body.removeEventListener('click', handleClick);
            document.body.removeEventListener('touchstart', handleTouchStart);
            document.body.removeEventListener('touchmove', handleTouchMove);
            document.body.removeEventListener('touchend', handleTouchEnd);
        }

        function handlePointerMove(e) {
            currentPointer.x = e.clientX;
            currentPointer.y = e.clientY;
            processPointerInteraction();
        }

        function handleClick(e) {
            currentPointer.x = e.clientX;
            currentPointer.y = e.clientY;
            for (const [elem, interaction] of pointerMap) {
                const rect = elem.getBoundingClientRect();
                updateInteractionPosition(interaction, rect);
                if (isPointerInBounds(rect)) interaction.onClick(interaction);
            }
        }

        function handlePointerLeave() {
            for (const interaction of pointerMap.values()) {
                if (interaction.hover) {
                    interaction.hover = false;
                    interaction.onLeave(interaction);
                }
            }
        }

        function handleTouchStart(e) {
            if (e.touches.length > 0) {
                e.preventDefault();
                currentPointer.x = e.touches[0].clientX;
                currentPointer.y = e.touches[0].clientY;
                
                for (const [elem, interaction] of pointerMap) {
                    const rect = elem.getBoundingClientRect();
                    if (isPointerInBounds(rect)) {
                        interaction.touching = true;
                        updateInteractionPosition(interaction, rect);
                        if (!interaction.hover) {
                            interaction.hover = true;
                            interaction.onEnter(interaction);
                        }
                        interaction.onMove(interaction);
                    }
                }
            }
        }

        function handleTouchMove(e) {
            if (e.touches.length > 0) {
                e.preventDefault();
                currentPointer.x = e.touches[0].clientX;
                currentPointer.y = e.touches[0].clientY;
                processPointerInteraction();
            }
        }

        function handleTouchEnd() {
            for (const interaction of pointerMap.values()) {
                if (interaction.touching) {
                    interaction.touching = false;
                    if (interaction.hover) {
                        interaction.hover = false;
                        interaction.onLeave(interaction);
                    }
                }
            }
        }

        function processPointerInteraction() {
            for (const [elem, interaction] of pointerMap) {
                const rect = elem.getBoundingClientRect();
                if (isPointerInBounds(rect)) {
                    updateInteractionPosition(interaction, rect);
                    if (!interaction.hover) {
                        interaction.hover = true;
                        interaction.onEnter(interaction);
                    }
                    interaction.onMove(interaction);
                } else if (interaction.hover && !interaction.touching) {
                    interaction.hover = false;
                    interaction.onLeave(interaction);
                }
            }
        }

        function updateInteractionPosition(interaction, rect) {
            const { position, nPosition } = interaction;
            position.x = currentPointer.x - rect.left;
            position.y = currentPointer.y - rect.top;
            nPosition.x = (position.x / rect.width) * 2 - 1;
            nPosition.y = (-position.y / rect.height) * 2 + 1;
        }

        function isPointerInBounds(rect) {
            const { x, y } = currentPointer;
            const { left, top, width, height } = rect;
            return x >= left && x <= left + width && y >= top && y <= top + height;
        }

        // Physics simulation
        const { randFloat, randFloatSpread } = MathUtils;
        
        class BallPhysics {
            constructor(config) {
                this.config = config;
                this.positionData = new Float32Array(3 * config.count).fill(0);
                this.velocityData = new Float32Array(3 * config.count).fill(0);
                this.sizeData = new Float32Array(config.count).fill(1);
                this.center = new Vector3();
                this.initializePositions();
                this.setSizes();
            }
            
            initializePositions() {
                const { config, positionData } = this;
                this.center.toArray(positionData, 0);
                for (let i = 1; i < config.count; i++) {
                    const base = 3 * i;
                    positionData[base] = randFloatSpread(2 * config.maxX);
                    positionData[base + 1] = randFloatSpread(2 * config.maxY);
                    positionData[base + 2] = randFloatSpread(2 * config.maxZ);
                }
            }
            
            setSizes() {
                const { config, sizeData } = this;
                sizeData[0] = config.size0;
                for (let i = 1; i < config.count; i++) {
                    sizeData[i] = randFloat(config.minSize, config.maxSize);
                }
            }
            
            update(time) {
                const { config, center, positionData, sizeData, velocityData } = this;
                
                // Temporary vectors for calculations
                const pos = new Vector3();
                const vel = new Vector3();
                const otherPos = new Vector3();
                const otherVel = new Vector3();
                const diff = new Vector3();
                const pushForce = new Vector3();
                const velAdjust = new Vector3();
                const otherVelAdjust = new Vector3();
                
                let startIdx = 0;
                
                // Handle control sphere
                if (config.controlSphere0) {
                    startIdx = 1;
                    pos.fromArray(positionData, 0);
                    pos.lerp(center, 0.1).toArray(positionData, 0);
                    vel.set(0, 0, 0).toArray(velocityData, 0);
                }
                
                // Apply gravity and friction
                for (let i = startIdx; i < config.count; i++) {
                    const base = 3 * i;
                    vel.fromArray(velocityData, base);
                    vel.y -= time.delta * config.gravity * sizeData[i];
                    vel.multiplyScalar(config.friction);
                    vel.clampLength(0, config.maxVelocity);
                    
                    pos.fromArray(positionData, base);
                    pos.add(vel);
                    pos.toArray(positionData, base);
                    vel.toArray(velocityData, base);
                }
                
                // Handle collisions
                for (let i = startIdx; i < config.count; i++) {
                    const base = 3 * i;
                    pos.fromArray(positionData, base);
                    vel.fromArray(velocityData, base);
                    const radius = sizeData[i];
                    
                    for (let j = i + 1; j < config.count; j++) {
                        const otherBase = 3 * j;
                        otherPos.fromArray(positionData, otherBase);
                        otherVel.fromArray(velocityData, otherBase);
                        const otherRadius = sizeData[j];
                        
                        diff.copy(otherPos).sub(pos);
                        const distance = diff.length();
                        const sumRadius = radius + otherRadius;
                        
                        if (distance < sumRadius) {
                            const overlap = sumRadius - distance;
                            pushForce.copy(diff).normalize().multiplyScalar(0.5 * overlap);
                            velAdjust.copy(pushForce).multiplyScalar(Math.max(vel.length(), 1));
                            otherVelAdjust.copy(pushForce).multiplyScalar(Math.max(otherVel.length(), 1));
                            
                            pos.sub(pushForce);
                            vel.sub(velAdjust);
                            pos.toArray(positionData, base);
                            vel.toArray(velocityData, base);
                            
                            otherPos.add(pushForce);
                            otherVel.add(otherVelAdjust);
                            otherPos.toArray(positionData, otherBase);
                            otherVel.toArray(velocityData, otherBase);
                        }
                    }
                    
                    // Collision with control sphere
                    if (config.controlSphere0) {
                        const controlPos = new Vector3().fromArray(positionData, 0);
                        diff.copy(controlPos).sub(pos);
                        const distance = diff.length();
                        const sumRadius = radius + sizeData[0];
                        
                        if (distance < sumRadius) {
                            const overlap = sumRadius - distance;
                            pushForce.copy(diff.normalize()).multiplyScalar(overlap);
                            velAdjust.copy(pushForce).multiplyScalar(Math.max(vel.length(), 2));
                            
                            pos.sub(pushForce);
                            vel.sub(velAdjust);
                        }
                    }
                    
                    // Wall collisions
                    if (Math.abs(pos.x) + radius > config.maxX) {
                        pos.x = Math.sign(pos.x) * (config.maxX - radius);
                        vel.x = -vel.x * config.wallBounce;
                    }
                    
                    if (config.gravity === 0) {
                        if (Math.abs(pos.y) + radius > config.maxY) {
                            pos.y = Math.sign(pos.y) * (config.maxY - radius);
                            vel.y = -vel.y * config.wallBounce;
                        }
                    } else if (pos.y - radius < -config.maxY) {
                        pos.y = -config.maxY + radius;
                        vel.y = -vel.y * config.wallBounce;
                    }
                    
                    const maxBoundary = Math.max(config.maxZ, config.maxSize);
                    if (Math.abs(pos.z) + radius > maxBoundary) {
                        pos.z = Math.sign(pos.z) * (config.maxZ - radius);
                        vel.z = -vel.z * config.wallBounce;
                    }
                    
                    pos.toArray(positionData, base);
                    vel.toArray(velocityData, base);
                }
            }
        }

        // Enhanced material with subsurface scattering
        class SubsurfaceMaterial extends MeshPhysicalMaterial {
            constructor(config) {
                super(config);
                this.uniforms = {
                    thicknessDistortion: { value: 0.1 },
                    thicknessAmbient: { value: 0 },
                    thicknessAttenuation: { value: 0.1 },
                    thicknessPower: { value: 2 },
                    thicknessScale: { value: 10 }
                };
                this.defines.USE_UV = '';
                this.onBeforeCompile = this.modifyShader.bind(this);
            }
            
            modifyShader(shader) {
                Object.assign(shader.uniforms, this.uniforms);
                
                shader.fragmentShader = `
                    uniform float thicknessPower;
                    uniform float thicknessScale;
                    uniform float thicknessDistortion;
                    uniform float thicknessAmbient;
                    uniform float thicknessAttenuation;
                ` + shader.fragmentShader;
                
                shader.fragmentShader = shader.fragmentShader.replace(
                    'void main() {',
                    `
                    void RE_Direct_Scattering(const in IncidentLight directLight, const in vec2 uv, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, inout ReflectedLight reflectedLight) {
                        vec3 scatteringHalf = normalize(directLight.direction + (geometryNormal * thicknessDistortion));
                        float scatteringDot = pow(saturate(dot(geometryViewDir, -scatteringHalf)), thicknessPower) * thicknessScale;
                        #ifdef USE_COLOR
                            vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * vColor;
                        #else
                            vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * diffuse;
                        #endif
                        reflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;
                    }

                    void main() {
                    `
                );
                
                const lightFragment = ShaderChunk.lights_fragment_begin.replaceAll(
                    'RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );',
                    `
                        RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
                        RE_Direct_Scattering(directLight, vUv, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, reflectedLight);
                    `
                );
                
                shader.fragmentShader = shader.fragmentShader.replace('#include <lights_fragment_begin>', lightFragment);
            }
        }

        // Default configuration
        const defaultConfig = {
            count: 200,
            colors: [0x6366f1, 0x8b5cf6, 0xec4899, 0xf59e0b],
            ambientColor: 0xffffff,
            ambientIntensity: 1,
            lightIntensity: 200,
            materialParams: {
                metalness: 0.5,
                roughness: 0.5,
                clearcoat: 1,
                clearcoatRoughness: 0.15
            },
            minSize: 0.5,
            maxSize: 1,
            size0: 1,
            gravity: 0.5,
            friction: 0.9975,
            wallBounce: 0.95,
            maxVelocity: 0.15,
            maxX: 5,
            maxY: 5,
            maxZ: 2,
            controlSphere0: false,
            followCursor: true
        };

        // Main Ballpit class
        class Ballpit extends InstancedMesh {
            constructor(renderer, config = {}) {
                const finalConfig = { ...defaultConfig, ...config };
                
                // Create environment map
                const roomEnvironment = new RoomEnvironment();
                const pmremGenerator = new PMREMGenerator(renderer, 0.04);
                const envMap = pmremGenerator.fromScene(roomEnvironment).texture;
                
                // Create geometry and material
                const geometry = new SphereGeometry();
                const material = new SubsurfaceMaterial({ envMap, ...finalConfig.materialParams });
                material.envMapRotation.x = -Math.PI / 2;
                
                super(geometry, material, finalConfig.count);
                
                this.config = finalConfig;
                this.physics = new BallPhysics(finalConfig);
                this.setupLighting();
                this.setColors(finalConfig.colors);
            }
            
            setupLighting() {
                this.ambientLight = new AmbientLight(this.config.ambientColor, this.config.ambientIntensity);
                this.add(this.ambientLight);
                this.light = new PointLight(this.config.colors[0], this.config.lightIntensity);
                this.add(this.light);
            }
            
            setColors(colors) {
                if (Array.isArray(colors) && colors.length > 1) {
                    const gradient = this.createColorGradient(colors);
                    for (let i = 0; i < this.count; i++) {
                        this.setColorAt(i, gradient.getColorAt(i / this.count));
                        if (i === 0) {
                            this.light.color.copy(gradient.getColorAt(i / this.count));
                        }
                    }
                    this.instanceColor.needsUpdate = true;
                }
            }
            
            createColorGradient(colors) {
                let colorArray, colorObjects;
                
                function setColors(newColors) {
                    colorArray = newColors;
                    colorObjects = [];
                    colorArray.forEach(color => {
                        colorObjects.push(new Color(color));
                    });
                }
                
                setColors(colors);
                
                return {
                    setColors,
                    getColorAt: function(ratio, output = new Color()) {
                        const scaledRatio = Math.max(0, Math.min(1, ratio)) * (colorArray.length - 1);
                        const index = Math.floor(scaledRatio);
                        const startColor = colorObjects[index];
                        
                        if (index >= colorArray.length - 1) return startColor.clone();
                        
                        const alpha = scaledRatio - index;
                        const endColor = colorObjects[index + 1];
                        
                        output.r = startColor.r + alpha * (endColor.r - startColor.r);
                        output.g = startColor.g + alpha * (endColor.g - startColor.g);
                        output.b = startColor.b + alpha * (endColor.b - startColor.b);
                        
                        return output;
                    }
                };
            }
            
            update(time) {
                this.physics.update(time);
                
                const tempObject = new Object3D();
                
                for (let i = 0; i < this.count; i++) {
                    tempObject.position.fromArray(this.physics.positionData, 3 * i);
                    
                    if (i === 0 && this.config.followCursor === false) {
                        tempObject.scale.setScalar(0);
                    } else {
                        tempObject.scale.setScalar(this.physics.sizeData[i]);
                    }
                    
                    tempObject.updateMatrix();
                    this.setMatrixAt(i, tempObject.matrix);
                    
                    if (i === 0) this.light.position.copy(tempObject.position);
                }
                
                this.instanceMatrix.needsUpdate = true;
            }
        }

        // Main function to create ballpit
        function createBallpit(canvas, config = {}) {
            const three = new ThreeCore({
                canvas: canvas,
                size: 'parent',
                rendererOptions: { antialias: true, alpha: true }
            });
            
            let ballpit;
            
            three.renderer.toneMapping = ACESFilmicToneMapping;
            three.camera.position.set(0, 0, 20);
            three.camera.lookAt(0, 0, 0);
            three.cameraMaxAspect = 1.5;
            three.resize();
            
            initialize(config);
            
            const raycaster = new Raycaster();
            const plane = new Plane(new Vector3(0, 0, 1), 0);
            const intersectionPoint = new Vector3();
            let isPaused = false;
            
            canvas.style.touchAction = 'none';
            canvas.style.userSelect = 'none';
            canvas.style.webkitUserSelect = 'none';
            
            const pointerInteraction = createPointerInteraction({
                domElement: canvas,
                onMove() {
                    raycaster.setFromCamera(pointerInteraction.nPosition, three.camera);
                    three.camera.getWorldDirection(plane.normal);
                    raycaster.ray.intersectPlane(plane, intersectionPoint);
                    ballpit.physics.center.copy(intersectionPoint);
                    ballpit.config.controlSphere0 = true;
                },
                onLeave() {
                    ballpit.config.controlSphere0 = false;
                }
            });
            
            function initialize(config) {
                if (ballpit) {
                    three.scene.remove(ballpit);
                }
                ballpit = new Ballpit(three.renderer, config);
                three.scene.add(ballpit);
            }
            
            three.onBeforeRender = (time) => {
                if (!isPaused) ballpit.update(time);
            };
            
            three.onAfterResize = (size) => {
                ballpit.config.maxX = size.wWidth / 2;
                ballpit.config.maxY = size.wHeight / 2;
            };
            
            return {
                three: three,
                get spheres() {
                    return ballpit;
                },
                setCount(count) {
                    initialize({ ...ballpit.config, count: count });
                },
                togglePause() {
                    isPaused = !isPaused;
                },
                dispose() {
                    pointerInteraction.dispose();
                    three.dispose();
                }
            };
        }

        // Initialize the ballpit when page loads
        document.addEventListener('DOMContentLoaded', function() {
            const canvas = document.getElementById('ballpit-canvas');
            
            if (canvas) {
                // Create the ballpit with custom configuration
                const ballpitInstance = createBallpit(canvas, {
                    count: 150,
                    colors: [0x6366f1, 0x8b5cf6, 0xec4899, 0xf59e0b], // Blue to purple to pink to orange gradient
                    followCursor: true,
                    gravity: 0.7,
                    friction: 0.995
                });
                
                // Optional: expose to global scope for debugging
                window.ballpit = ballpitInstance;
            }
        });
